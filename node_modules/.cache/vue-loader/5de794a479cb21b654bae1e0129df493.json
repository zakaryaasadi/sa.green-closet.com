{"remainingRequest":"D:\\Projects\\Web Projects\\new-greenclosetuk.com\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Projects\\Web Projects\\new-greenclosetuk.com\\node_modules\\vue-google-autocomplete\\src\\VueGoogleAutocomplete.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Projects\\Web Projects\\new-greenclosetuk.com\\node_modules\\vue-google-autocomplete\\src\\VueGoogleAutocomplete.vue","mtime":1655981866336},{"path":"D:\\Projects\\Web Projects\\new-greenclosetuk.com\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1655981863969},{"path":"D:\\Projects\\Web Projects\\new-greenclosetuk.com\\node_modules\\babel-loader\\lib\\index.js","mtime":1655981866419},{"path":"D:\\Projects\\Web Projects\\new-greenclosetuk.com\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1655981863969},{"path":"D:\\Projects\\Web Projects\\new-greenclosetuk.com\\node_modules\\vue-loader\\lib\\index.js","mtime":1655981865577}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCiAgICBjb25zdCBBRERSRVNTX0NPTVBPTkVOVFMgPSB7CiAgICAgICAgc3VicHJlbWlzZSA6ICdzaG9ydF9uYW1lJywKICAgICAgICBzdHJlZXRfbnVtYmVyOiAnc2hvcnRfbmFtZScsCiAgICAgICAgcm91dGU6ICdsb25nX25hbWUnLAogICAgICAgIGxvY2FsaXR5OiAnbG9uZ19uYW1lJywKICAgICAgICBhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzE6ICdzaG9ydF9uYW1lJywKICAgICAgICBhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzI6ICdsb25nX25hbWUnLAogICAgICAgIGNvdW50cnk6ICdsb25nX25hbWUnLAogICAgICAgIHBvc3RhbF9jb2RlOiAnc2hvcnRfbmFtZScKICAgIH07CgogICAgY29uc3QgQ0lUSUVTX1RZUEUgPSBbJ2xvY2FsaXR5JywgJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMyddOwogICAgY29uc3QgUkVHSU9OU19UWVBFID0gWydsb2NhbGl0eScsICdzdWJsb2NhbGl0eScsICdwb3N0YWxfY29kZScsICdjb3VudHJ5JywKICAgICAgICAnYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8xJywgJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMiddOwoKICAgIC8qCiAgICAgIEJ5IGRlZmF1bHQsIHdlJ3JlIG9ubHkgaW5jbHVkaW5nIGJhc2ljIHBsYWNlIGRhdGEgYmVjYXVzZSByZXF1ZXN0aW5nIHRoZXNlIAogICAgICBmaWVsZHMgcGxhY2UgZGF0YSBpcyBub3QgYWRkaXRpb25hbGx5IGNoYXJnZWQgYnkgR29vZ2xlLiBQbGVhc2UgcmVmZXIgdG86CgogICAgICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2JpbGxpbmcvdW5kZXJzdGFuZGluZy1jb3N0LW9mLXVzZSNiYXNpYy1kYXRhCiAgICAqLwogICAgY29uc3QgQkFTSUNfREFUQV9GSUVMRFMgPSBbJ2FkZHJlc3NfY29tcG9uZW50cycsICdhZHJfYWRkcmVzcycsICdhbHRfaWQnLCAKICAgICAgICAnZm9ybWF0dGVkX2FkZHJlc3MnLCAnZ2VvbWV0cnknLCAnaWNvbicsICdpZCcsICduYW1lJywgCiAgICAgICAgJ2J1c2luZXNzX3N0YXR1cycsICdwaG90bycsICdwbGFjZV9pZCcsICdzY29wZScsICd0eXBlJywgJ3VybCcsIAogICAgICAgICd1dGNfb2Zmc2V0X21pbnV0ZXMnLCAndmljaW5pdHknXTsKCiAgICBleHBvcnQgZGVmYXVsdCB7CiAgICAgICAgbmFtZTogJ1Z1ZUdvb2dsZUF1dG9jb21wbGV0ZScsCgogICAgICAgIHByb3BzOiB7CiAgICAgICAgICBpZDogewogICAgICAgICAgICB0eXBlOiBTdHJpbmcsCiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlCiAgICAgICAgICB9LAoKICAgICAgICAgIGNsYXNzbmFtZTogU3RyaW5nLAoKICAgICAgICAgIHBsYWNlaG9sZGVyOiB7CiAgICAgICAgICAgIHR5cGU6IFN0cmluZywKICAgICAgICAgICAgZGVmYXVsdDogJ1N0YXJ0IHR5cGluZycKICAgICAgICAgIH0sCgogICAgICAgICAgZGlzYWJsZWQ6IHsKICAgICAgICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UKICAgICAgICAgIH0sCgogICAgICAgICAgdHlwZXM6IHsKICAgICAgICAgICAgdHlwZTogU3RyaW5nLAogICAgICAgICAgICBkZWZhdWx0OiAnYWRkcmVzcycKICAgICAgICAgIH0sCgogICAgICAgICAgZmllbGRzOiB7CiAgICAgICAgICAgIHR5cGU6IEFycmF5LAogICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICByZXR1cm4gQkFTSUNfREFUQV9GSUVMRFM7CiAgICAgICAgICAgIH0sCiAgICAgICAgICB9LAoKICAgICAgICAgIGNvdW50cnk6IHsKICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLAogICAgICAgICAgICBkZWZhdWx0OiBudWxsCiAgICAgICAgICB9LAoKICAgICAgICAgIGVuYWJsZUdlb2xvY2F0aW9uOiB7CiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICAgICAgICB9LAoKICAgICAgICAgIGdlb2xvY2F0aW9uT3B0aW9uczogewogICAgICAgICAgICB0eXBlOiBPYmplY3QsCiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwKICAgICAgICAgIH0KICAgICAgICB9LAoKICAgICAgICBkYXRhKCkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAgICAgKiBUaGUgQXV0b2NvbXBsZXRlIG9iamVjdC4KICAgICAgICAgICAgICAgICAqCiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXV0b2NvbXBsZXRlfQogICAgICAgICAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI0F1dG9jb21wbGV0ZQogICAgICAgICAgICAgICAgICovCiAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6IG51bGwsCgogICAgICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAgICAgKiBBdXRvY29tcGxldGUgaW5wdXQgdGV4dAogICAgICAgICAgICAgICAgICogQHR5cGUge1N0cmluZ30KICAgICAgICAgICAgICAgICAqLwogICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlVGV4dDogJycsCgogICAgICAgICAgICAgICAgZ2VvbG9jYXRpb246IHsKICAgICAgICAgICAgICAgICAgICAvKioKICAgICAgICAgICAgICAgICAgICAgKiBHb29nbGUgR2VvY29kZXIgT2JqZXQKICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7R2VvY29kZXJ9CiAgICAgICAgICAgICAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI0dlb2NvZGVyCiAgICAgICAgICAgICAgICAgICAgICovCiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZXI6IG51bGwsCgogICAgICAgICAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgICAgICAgICAqIEZpbGxlZCBhZnRlciBnZW9sb2NhdGUgcmVzdWx0CiAgICAgICAgICAgICAgICAgICAgICogQHR5cGUge0Nvb3JkaW5hdGVzfQogICAgICAgICAgICAgICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Db29yZGluYXRlcwogICAgICAgICAgICAgICAgICAgICAqLwogICAgICAgICAgICAgICAgICAgIGxvYzogbnVsbCwKCiAgICAgICAgICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAgICAgICAgICogRmlsbGVkIGFmdGVyIGdlb2xvY2F0ZSByZXN1bHQKICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UG9zaXRpb259CiAgICAgICAgICAgICAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Bvc2l0aW9uCiAgICAgICAgICAgICAgICAgICAgICovCiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG51bGwKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCgogICAgICAgIHdhdGNoOiB7CiAgICAgICAgICAgIGF1dG9jb21wbGV0ZVRleHQ6IGZ1bmN0aW9uIChuZXdWYWwsIG9sZFZhbCkgewoJICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXRDaGFuZ2UnLCB7IG5ld1ZhbCwgb2xkVmFsIH0sIHRoaXMuaWQpOwogICAgICAgICAgICB9LAogICAgICAgICAgICBjb3VudHJ5OiBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCkgewogICAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLnNldENvbXBvbmVudFJlc3RyaWN0aW9ucyh7CiAgICAgICAgICAgICAgICBjb3VudHJ5OiB0aGlzLmNvdW50cnkgPT09IG51bGwgPyBbXSA6IHRoaXMuY291bnRyeQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgfSwKCiAgICAgICAgbW91bnRlZDogZnVuY3Rpb24oKSB7CiAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307CgogICAgICAgICAgaWYgKHRoaXMudHlwZXMpIHsKICAgICAgICAgICAgb3B0aW9ucy50eXBlcyA9IFt0aGlzLnR5cGVzXTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAodGhpcy5jb3VudHJ5KSB7CiAgICAgICAgICAgIG9wdGlvbnMuY29tcG9uZW50UmVzdHJpY3Rpb25zID0gewogICAgICAgICAgICAgIGNvdW50cnk6IHRoaXMuY291bnRyeQogICAgICAgICAgICB9OwogICAgICAgICAgfQoKICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlID0gbmV3IGdvb2dsZS5tYXBzLnBsYWNlcy5BdXRvY29tcGxldGUoCiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKSwKICAgICAgICAgICAgICAgIG9wdGlvbnMKICAgICAgICAgICAgKTsKCiAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5zZXRGaWVsZHModGhpcy5maWVsZHMpOwoKICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLmFkZExpc3RlbmVyKCdwbGFjZV9jaGFuZ2VkJywgdGhpcy5vblBsYWNlQ2hhbmdlZCk7CiAgICAgICAgfSwKCiAgICAgICAgbWV0aG9kczogewogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogV2hlbiBhIHBsYWNlIGNoYW5nZWQKICAgICAgICAgICAgICovCiAgICAgICAgICAgIG9uUGxhY2VDaGFuZ2VkKCkgewogICAgICAgICAgICAgICAgbGV0IHBsYWNlID0gdGhpcy5hdXRvY29tcGxldGUuZ2V0UGxhY2UoKTsKCiAgICAgICAgICAgICAgICBpZiAoIXBsYWNlLmdlb21ldHJ5KSB7CiAgICAgICAgICAgICAgICAgIC8vIFVzZXIgZW50ZXJlZCB0aGUgbmFtZSBvZiBhIFBsYWNlIHRoYXQgd2FzIG5vdCBzdWdnZXN0ZWQgYW5kCiAgICAgICAgICAgICAgICAgIC8vIHByZXNzZWQgdGhlIEVudGVyIGtleSwgb3IgdGhlIFBsYWNlIERldGFpbHMgcmVxdWVzdCBmYWlsZWQuCiAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ25vLXJlc3VsdHMtZm91bmQnLCBwbGFjZSwgdGhpcy5pZCk7CiAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAocGxhY2UuYWRkcmVzc19jb21wb25lbnRzICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmV0dXJuRGF0YSBvYmplY3QgYW5kIFBsYWNlUmVzdWx0IG9iamVjdAogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3BsYWNlY2hhbmdlZCcsIHRoaXMuZm9ybWF0UmVzdWx0KHBsYWNlKSwgcGxhY2UsIHRoaXMuaWQpOwoKICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYXV0b2NvbXBsZXRlVGV4dCB0aGVuIGVtaXQgY2hhbmdlIGV2ZW50CiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGVUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCkudmFsdWUKICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCkKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiBXaGVuIHRoZSBpbnB1dCBnZXRzIGZvY3VzCiAgICAgICAgICAgICAqLwogICAgICAgICAgICBvbkZvY3VzKCkgewogICAgICAgICAgICAgIHRoaXMuYmlhc0F1dG9jb21wbGV0ZUxvY2F0aW9uKCk7CiAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZm9jdXMnKTsKICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiBXaGVuIHRoZSBpbnB1dCBsb3NlcyBmb2N1cwogICAgICAgICAgICAgKi8KICAgICAgICAgICAgb25CbHVyKCkgewogICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2JsdXInKTsKICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiBXaGVuIHRoZSBpbnB1dCBnb3QgY2hhbmdlZAogICAgICAgICAgICAgKi8KICAgICAgICAgICAgb25DaGFuZ2UoKSB7CiAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5hdXRvY29tcGxldGVUZXh0KTsKICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiBXaGVuIGEga2V5IGdldHMgcHJlc3NlZAogICAgICAgICAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnQgQSBrZXlwcmVzcyBldmVudAogICAgICAgICAgICAgKi8KICAgICAgICAgICAgb25LZXlQcmVzcyhldmVudCkgewogICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2tleXByZXNzJywgZXZlbnQpOwogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIFdoZW4gYSBrZXl1cCBvY2N1cnMKICAgICAgICAgICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IEEga2V5dXAgZXZlbnQKICAgICAgICAgICAgICovCiAgICAgICAgICAgIG9uS2V5VXAoZXZlbnQpIHsKICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdrZXl1cCcsIGV2ZW50KTsKICAgICAgICAgICAgfSwKCiAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgKiBDbGVhciB0aGUgaW5wdXQKICAgICAgICAgICAgICovCiAgICAgICAgICAgIGNsZWFyKCkgewogICAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlVGV4dCA9ICcnCiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogRm9jdXMgdGhlIGlucHV0CiAgICAgICAgICAgICAqLwogICAgICAgICAgICBmb2N1cygpIHsKICAgICAgICAgICAgICB0aGlzLiRyZWZzLmF1dG9jb21wbGV0ZS5mb2N1cygpCiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogQmx1ciB0aGUgaW5wdXQKICAgICAgICAgICAgICovCiAgICAgICAgICAgIGJsdXIoKSB7CiAgICAgICAgICAgICAgdGhpcy4kcmVmcy5hdXRvY29tcGxldGUuYmx1cigpCiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogVXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQKICAgICAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZQogICAgICAgICAgICAgKi8KICAgICAgICAgICAgdXBkYXRlICh2YWx1ZSkgewogICAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlVGV4dCA9IHZhbHVlCiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogVXBkYXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW5wdXQKICAgICAgICAgICAgICogQHBhcmFtICB7Q29vcmRpbmF0ZXN9IHZhbHVlCiAgICAgICAgICAgICAqLwogICAgICAgICAgICB1cGRhdGVDb29yZGluYXRlcyAodmFsdWUpIHsKICAgICAgICAgICAgICAgIGlmICghdmFsdWUgJiYgISh2YWx1ZS5sYXQgfHwgdmFsdWUubG5nKSkgcmV0dXJuOwogICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdlb2xvY2F0aW9uLmdlb2NvZGVyKSB0aGlzLmdlb2xvY2F0aW9uLmdlb2NvZGVyID0gbmV3IGdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7CiAgICAgICAgICAgICAgICB0aGlzLmdlb2xvY2F0aW9uLmdlb2NvZGVyLmdlb2NvZGUoeydsb2NhdGlvbic6IHZhbHVlfSwgKHJlc3VsdHMsIHN0YXR1cykgPT4gewogICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdPSycpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHRoaXMuZmlsdGVyR2VvY29kZVJlc3VsdFR5cGVzKHJlc3VsdHMpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1swXSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgncGxhY2VjaGFuZ2VkJywgdGhpcy5mb3JtYXRSZXN1bHQocmVzdWx0c1swXSksIHJlc3VsdHNbMF0sIHRoaXMuaWQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUocmVzdWx0c1swXS5mb3JtYXR0ZWRfYWRkcmVzcyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdlcnJvcicsICdubyByZXN1bHQgZm9yIHByb3ZpZGVkIGNvb3JkaW5hdGVzJyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdlcnJvcicsICdlcnJvciBnZXR0aW5nIGFkZHJlc3MgZnJvbSBjb29yZHMnKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIFVwZGF0ZSBsb2NhdGlvbiBiYXNlZCBvbiBuYXZpZ2F0b3IgZ2VvbG9jYXRpb24KICAgICAgICAgICAgICovCiAgICAgICAgICAgIGdlb2xvY2F0ZSAoKSB7CiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUdlb2xvY2F0aW9uICgoZ2VvbG9jYXRpb24sIHBvc2l0aW9uKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb29yZGluYXRlcyhnZW9sb2NhdGlvbikKICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogVXBkYXRlIGludGVybmFsIGxvY2F0aW9uIGZyb20gbmF2aWdhdG9yIGdlb2xvY2F0aW9uCiAgICAgICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAoZ2VvbG9jYXRpb24sIHBvc2l0aW9uKQogICAgICAgICAgICAgKi8KICAgICAgICAgICAgdXBkYXRlR2VvbG9jYXRpb24gKGNhbGxiYWNrID0gbnVsbCkgewogICAgICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikgewogICAgICAgICAgICAgICAgICAgIGxldCBvcHRpb25zID0ge307CiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5nZW9sb2NhdGlvbk9wdGlvbnMpIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5nZW9sb2NhdGlvbk9wdGlvbnMpOwogICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ocG9zaXRpb24gPT4gewogICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ2VvbG9jYXRpb24gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXQ6IHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxuZzogcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZQogICAgICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlb2xvY2F0aW9uLmxvYyA9IGdlb2xvY2F0aW9uOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlb2xvY2F0aW9uLnBvc2l0aW9uID0gcG9zaXRpb247CgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGdlb2xvY2F0aW9uLCBwb3NpdGlvbik7CiAgICAgICAgICAgICAgICAgICAgfSwgZXJyID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCAnQ2Fubm90IGdldCBDb29yZGluYXRlcyBmcm9tIG5hdmlnYXRvcicsIGVycik7CiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCgoKICAgICAgICAgICAgLy8gQmlhcyB0aGUgYXV0b2NvbXBsZXRlIG9iamVjdCB0byB0aGUgdXNlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbiwKICAgICAgICAgICAgLy8gYXMgc3VwcGxpZWQgYnkgdGhlIGJyb3dzZXIncyAnbmF2aWdhdG9yLmdlb2xvY2F0aW9uJyBvYmplY3QuCiAgICAgICAgICAgIGJpYXNBdXRvY29tcGxldGVMb2NhdGlvbiAoKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVHZW9sb2NhdGlvbikgewogICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlR2VvbG9jYXRpb24oKGdlb2xvY2F0aW9uLCBwb3NpdGlvbikgPT4gewogICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2lyY2xlID0gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZSh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IGdlb2xvY2F0aW9uLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3kKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLnNldEJvdW5kcyhjaXJjbGUuZ2V0Qm91bmRzKCkpOwogICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCgogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogRm9ybWF0IHJlc3VsdCBmcm9tIEdlbyBnb29nbGUgQVBJcwogICAgICAgICAgICAgKiBAcGFyYW0gcGxhY2UKICAgICAgICAgICAgICogQHJldHVybnMge3tmb3JtYXR0ZWQgb3V0cHV0fX0KICAgICAgICAgICAgICovCiAgICAgICAgICAgIGZvcm1hdFJlc3VsdCAocGxhY2UpIHsKICAgICAgICAgICAgICAgIGxldCByZXR1cm5EYXRhID0ge307CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYWNlLmFkZHJlc3NfY29tcG9uZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgIGxldCBhZGRyZXNzVHlwZSA9IHBsYWNlLmFkZHJlc3NfY29tcG9uZW50c1tpXS50eXBlc1swXTsKCiAgICAgICAgICAgICAgICAgICAgaWYgKEFERFJFU1NfQ09NUE9ORU5UU1thZGRyZXNzVHlwZV0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHBsYWNlLmFkZHJlc3NfY29tcG9uZW50c1tpXVtBRERSRVNTX0NPTVBPTkVOVFNbYWRkcmVzc1R5cGVdXTsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRGF0YVthZGRyZXNzVHlwZV0gPSB2YWw7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHJldHVybkRhdGFbJ2xhdGl0dWRlJ10gPSBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKTsKICAgICAgICAgICAgICAgIHJldHVybkRhdGFbJ2xvbmdpdHVkZSddID0gcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24ubG5nKCk7CiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuRGF0YQogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoqCiAgICAgICAgICAgICAqIEV4dHJhY3QgY29uZmlndXJlZCB0eXBlcyBvdXQgb2YgcmF3IHJlc3VsdCBhcwogICAgICAgICAgICAgKiBHZW9jb2RlIEFQSSBkb2VzIG5vdCBhbGxvdyB0byBkbyBpdAogICAgICAgICAgICAgKiBAcGFyYW0gcmVzdWx0cwogICAgICAgICAgICAgKiBAcmV0dXJucyB7R2VvY29kZXJSZXN1bHR9CiAgICAgICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNHZW9jb2RlclJlc3VsdAogICAgICAgICAgICAgKi8KICAgICAgICAgICAgZmlsdGVyR2VvY29kZVJlc3VsdFR5cGVzIChyZXN1bHRzKSB7CiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMgfHwgIXRoaXMudHlwZXMpIHJldHVybiByZXN1bHRzOwogICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IFtdOwogICAgICAgICAgICAgICAgbGV0IHR5cGVzID0gW3RoaXMudHlwZXNdOwogICAgICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCcoY2l0aWVzKScpKSB0eXBlcyA9IHR5cGVzLmNvbmNhdChDSVRJRVNfVFlQRSk7CiAgICAgICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJyhyZWdpb25zKScpKSB0eXBlcyA9IHR5cGVzLmNvbmNhdChSRUdJT05TX1RZUEUpOwoKICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgcmVzdWx0cykgewogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2Ygci50eXBlcykgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXModCkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0OwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQo="},{"version":3,"sources":["VueGoogleAutocomplete.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"VueGoogleAutocomplete.vue","sourceRoot":"node_modules/vue-google-autocomplete/src","sourcesContent":["<template>\n    <input\n        ref=\"autocomplete\"\n        type=\"text\"\n        :class=\"classname\"\n        :id=\"id\"\n        :placeholder=\"placeholder\"\n        :disabled=\"disabled\"\n        v-model=\"autocompleteText\"\n        @focus=\"onFocus()\"\n        @blur=\"onBlur()\"\n        @change=\"onChange\"\n        @keypress=\"onKeyPress\"\n        @keyup=\"onKeyUp\"\n    />\n</template>\n\n<script>\n    const ADDRESS_COMPONENTS = {\n        subpremise : 'short_name',\n        street_number: 'short_name',\n        route: 'long_name',\n        locality: 'long_name',\n        administrative_area_level_1: 'short_name',\n        administrative_area_level_2: 'long_name',\n        country: 'long_name',\n        postal_code: 'short_name'\n    };\n\n    const CITIES_TYPE = ['locality', 'administrative_area_level_3'];\n    const REGIONS_TYPE = ['locality', 'sublocality', 'postal_code', 'country',\n        'administrative_area_level_1', 'administrative_area_level_2'];\n\n    /*\n      By default, we're only including basic place data because requesting these \n      fields place data is not additionally charged by Google. Please refer to:\n\n      https://developers.google.com/maps/billing/understanding-cost-of-use#basic-data\n    */\n    const BASIC_DATA_FIELDS = ['address_components', 'adr_address', 'alt_id', \n        'formatted_address', 'geometry', 'icon', 'id', 'name', \n        'business_status', 'photo', 'place_id', 'scope', 'type', 'url', \n        'utc_offset_minutes', 'vicinity'];\n\n    export default {\n        name: 'VueGoogleAutocomplete',\n\n        props: {\n          id: {\n            type: String,\n            required: true\n          },\n\n          classname: String,\n\n          placeholder: {\n            type: String,\n            default: 'Start typing'\n          },\n\n          disabled: {\n            type: Boolean,\n            default: false\n          },\n\n          types: {\n            type: String,\n            default: 'address'\n          },\n\n          fields: {\n            type: Array,\n            default: function() {\n              return BASIC_DATA_FIELDS;\n            },\n          },\n\n          country: {\n            type: [String, Array],\n            default: null\n          },\n\n          enableGeolocation: {\n            type: Boolean,\n            default: false\n          },\n\n          geolocationOptions: {\n            type: Object,\n            default: null\n          }\n        },\n\n        data() {\n            return {\n                /**\n                 * The Autocomplete object.\n                 *\n                 * @type {Autocomplete}\n                 * @link https://developers.google.com/maps/documentation/javascript/reference#Autocomplete\n                 */\n                autocomplete: null,\n\n                /**\n                 * Autocomplete input text\n                 * @type {String}\n                 */\n                autocompleteText: '',\n\n                geolocation: {\n                    /**\n                     * Google Geocoder Objet\n                     * @type {Geocoder}\n                     * @link https://developers.google.com/maps/documentation/javascript/reference#Geocoder\n                     */\n                    geocoder: null,\n\n                    /**\n                     * Filled after geolocate result\n                     * @type {Coordinates}\n                     * @link https://developer.mozilla.org/en-US/docs/Web/API/Coordinates\n                     */\n                    loc: null,\n\n                    /**\n                     * Filled after geolocate result\n                     * @type {Position}\n                     * @link https://developer.mozilla.org/en-US/docs/Web/API/Position\n                     */\n                    position: null\n                }\n            }\n        },\n\n        watch: {\n            autocompleteText: function (newVal, oldVal) {\n\t            this.$emit('inputChange', { newVal, oldVal }, this.id);\n            },\n            country: function(newVal, oldVal) {\n              this.autocomplete.setComponentRestrictions({\n                country: this.country === null ? [] : this.country\n              });\n            }\n        },\n\n        mounted: function() {\n          const options = {};\n\n          if (this.types) {\n            options.types = [this.types];\n          }\n\n          if (this.country) {\n            options.componentRestrictions = {\n              country: this.country\n            };\n          }\n\n          this.autocomplete = new google.maps.places.Autocomplete(\n                document.getElementById(this.id),\n                options\n            );\n\n          this.autocomplete.setFields(this.fields);\n\n          this.autocomplete.addListener('place_changed', this.onPlaceChanged);\n        },\n\n        methods: {\n            /**\n             * When a place changed\n             */\n            onPlaceChanged() {\n                let place = this.autocomplete.getPlace();\n\n                if (!place.geometry) {\n                  // User entered the name of a Place that was not suggested and\n                  // pressed the Enter key, or the Place Details request failed.\n                  this.$emit('no-results-found', place, this.id);\n                  return;\n                }\n\n                if (place.address_components !== undefined) {\n                    // return returnData object and PlaceResult object\n                    this.$emit('placechanged', this.formatResult(place), place, this.id);\n\n                    // update autocompleteText then emit change event\n                    this.autocompleteText = document.getElementById(this.id).value\n                    this.onChange()\n                }\n            },\n\n            /**\n             * When the input gets focus\n             */\n            onFocus() {\n              this.biasAutocompleteLocation();\n              this.$emit('focus');\n            },\n\n            /**\n             * When the input loses focus\n             */\n            onBlur() {\n              this.$emit('blur');\n            },\n\n            /**\n             * When the input got changed\n             */\n            onChange() {\n              this.$emit('change', this.autocompleteText);\n            },\n\n            /**\n             * When a key gets pressed\n             * @param  {Event} event A keypress event\n             */\n            onKeyPress(event) {\n              this.$emit('keypress', event);\n            },\n\n            /**\n             * When a keyup occurs\n             * @param  {Event} event A keyup event\n             */\n            onKeyUp(event) {\n              this.$emit('keyup', event);\n            },\n\n            /**\n             * Clear the input\n             */\n            clear() {\n              this.autocompleteText = ''\n            },\n\n            /**\n             * Focus the input\n             */\n            focus() {\n              this.$refs.autocomplete.focus()\n            },\n\n            /**\n             * Blur the input\n             */\n            blur() {\n              this.$refs.autocomplete.blur()\n            },\n\n            /**\n             * Update the value of the input\n             * @param  {String} value\n             */\n            update (value) {\n              this.autocompleteText = value\n            },\n\n            /**\n             * Update the coordinates of the input\n             * @param  {Coordinates} value\n             */\n            updateCoordinates (value) {\n                if (!value && !(value.lat || value.lng)) return;\n                if (!this.geolocation.geocoder) this.geolocation.geocoder = new google.maps.Geocoder();\n                this.geolocation.geocoder.geocode({'location': value}, (results, status) => {\n                    if (status === 'OK') {\n                        results = this.filterGeocodeResultTypes(results);\n                        if (results[0]) {\n                            this.$emit('placechanged', this.formatResult(results[0]), results[0], this.id);\n                            this.update(results[0].formatted_address);\n                        } else {\n                            this.$emit('error', 'no result for provided coordinates');\n                        }\n                    } else {\n                        this.$emit('error', 'error getting address from coords');\n                    }\n                })\n            },\n\n            /**\n             * Update location based on navigator geolocation\n             */\n            geolocate () {\n                this.updateGeolocation ((geolocation, position) => {\n                    this.updateCoordinates(geolocation)\n                })\n            },\n\n            /**\n             * Update internal location from navigator geolocation\n             * @param  {Function} (geolocation, position)\n             */\n            updateGeolocation (callback = null) {\n                if (navigator.geolocation) {\n                    let options = {};\n                    if(this.geolocationOptions) Object.assign(options, this.geolocationOptions);\n                    navigator.geolocation.getCurrentPosition(position => {\n                        let geolocation = {\n                            lat: position.coords.latitude,\n                            lng: position.coords.longitude\n                        };\n                        this.geolocation.loc = geolocation;\n                        this.geolocation.position = position;\n\n                        if (callback) callback(geolocation, position);\n                    }, err => {\n                        this.$emit('error', 'Cannot get Coordinates from navigator', err);\n                    }, options);\n                }\n            },\n\n\n            // Bias the autocomplete object to the user's geographical location,\n            // as supplied by the browser's 'navigator.geolocation' object.\n            biasAutocompleteLocation () {\n                if (this.enableGeolocation) {\n                    this.updateGeolocation((geolocation, position) => {\n                        let circle = new google.maps.Circle({\n                            center: geolocation,\n                            radius: position.coords.accuracy\n                        });\n                        this.autocomplete.setBounds(circle.getBounds());\n                    })\n                }\n            },\n\n            /**\n             * Format result from Geo google APIs\n             * @param place\n             * @returns {{formatted output}}\n             */\n            formatResult (place) {\n                let returnData = {};\n                for (let i = 0; i < place.address_components.length; i++) {\n                    let addressType = place.address_components[i].types[0];\n\n                    if (ADDRESS_COMPONENTS[addressType]) {\n                        let val = place.address_components[i][ADDRESS_COMPONENTS[addressType]];\n                        returnData[addressType] = val;\n                    }\n                }\n\n                returnData['latitude'] = place.geometry.location.lat();\n                returnData['longitude'] = place.geometry.location.lng();\n                return returnData\n            },\n\n            /**\n             * Extract configured types out of raw result as\n             * Geocode API does not allow to do it\n             * @param results\n             * @returns {GeocoderResult}\n             * @link https://developers.google.com/maps/documentation/javascript/reference#GeocoderResult\n             */\n            filterGeocodeResultTypes (results) {\n                if (!results || !this.types) return results;\n                let output = [];\n                let types = [this.types];\n                if (types.includes('(cities)')) types = types.concat(CITIES_TYPE);\n                if (types.includes('(regions)')) types = types.concat(REGIONS_TYPE);\n\n                for (let r of results) {\n                    for (let t of r.types) {\n                        if (types.includes(t)) {\n                            output.push(r);\n                            break;\n                        }\n                    }\n                }\n                return output;\n            }\n        }\n    }\n</script>\n"]}]}