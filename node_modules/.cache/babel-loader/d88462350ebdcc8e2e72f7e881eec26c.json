{"remainingRequest":"D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\babel-loader\\lib\\index.js!D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\vue-google-autocomplete\\src\\VueGoogleAutocomplete.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\vue-google-autocomplete\\src\\VueGoogleAutocomplete.vue","mtime":1655981866336},{"path":"D:\\Projects\\Web Projects\\sa.green-closet.com\\babel.config.js","mtime":1642499299534},{"path":"D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1655981863969},{"path":"D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\babel-loader\\lib\\index.js","mtime":1655981866419},{"path":"D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1655981863969},{"path":"D:\\Projects\\Web Projects\\sa.green-closet.com\\node_modules\\vue-loader\\lib\\index.js","mtime":1655981865577}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMuanMiOwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwpjb25zdCBBRERSRVNTX0NPTVBPTkVOVFMgPSB7CiAgc3VicHJlbWlzZTogJ3Nob3J0X25hbWUnLAogIHN0cmVldF9udW1iZXI6ICdzaG9ydF9uYW1lJywKICByb3V0ZTogJ2xvbmdfbmFtZScsCiAgbG9jYWxpdHk6ICdsb25nX25hbWUnLAogIGFkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMTogJ3Nob3J0X25hbWUnLAogIGFkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMjogJ2xvbmdfbmFtZScsCiAgY291bnRyeTogJ2xvbmdfbmFtZScsCiAgcG9zdGFsX2NvZGU6ICdzaG9ydF9uYW1lJwp9Owpjb25zdCBDSVRJRVNfVFlQRSA9IFsnbG9jYWxpdHknLCAnYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8zJ107CmNvbnN0IFJFR0lPTlNfVFlQRSA9IFsnbG9jYWxpdHknLCAnc3VibG9jYWxpdHknLCAncG9zdGFsX2NvZGUnLCAnY291bnRyeScsICdhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzEnLCAnYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8yJ107Ci8qCiAgQnkgZGVmYXVsdCwgd2UncmUgb25seSBpbmNsdWRpbmcgYmFzaWMgcGxhY2UgZGF0YSBiZWNhdXNlIHJlcXVlc3RpbmcgdGhlc2UgCiAgZmllbGRzIHBsYWNlIGRhdGEgaXMgbm90IGFkZGl0aW9uYWxseSBjaGFyZ2VkIGJ5IEdvb2dsZS4gUGxlYXNlIHJlZmVyIHRvOgogICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2JpbGxpbmcvdW5kZXJzdGFuZGluZy1jb3N0LW9mLXVzZSNiYXNpYy1kYXRhCiovCgpjb25zdCBCQVNJQ19EQVRBX0ZJRUxEUyA9IFsnYWRkcmVzc19jb21wb25lbnRzJywgJ2Fkcl9hZGRyZXNzJywgJ2FsdF9pZCcsICdmb3JtYXR0ZWRfYWRkcmVzcycsICdnZW9tZXRyeScsICdpY29uJywgJ2lkJywgJ25hbWUnLCAnYnVzaW5lc3Nfc3RhdHVzJywgJ3Bob3RvJywgJ3BsYWNlX2lkJywgJ3Njb3BlJywgJ3R5cGUnLCAndXJsJywgJ3V0Y19vZmZzZXRfbWludXRlcycsICd2aWNpbml0eSddOwpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ1Z1ZUdvb2dsZUF1dG9jb21wbGV0ZScsCiAgcHJvcHM6IHsKICAgIGlkOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgcmVxdWlyZWQ6IHRydWUKICAgIH0sCiAgICBjbGFzc25hbWU6IFN0cmluZywKICAgIHBsYWNlaG9sZGVyOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogJ1N0YXJ0IHR5cGluZycKICAgIH0sCiAgICBkaXNhYmxlZDogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIHR5cGVzOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogJ2FkZHJlc3MnCiAgICB9LAogICAgZmllbGRzOiB7CiAgICAgIHR5cGU6IEFycmF5LAogICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIEJBU0lDX0RBVEFfRklFTERTOwogICAgICB9CiAgICB9LAogICAgY291bnRyeTogewogICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sCiAgICAgIGRlZmF1bHQ6IG51bGwKICAgIH0sCiAgICBlbmFibGVHZW9sb2NhdGlvbjogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIGdlb2xvY2F0aW9uT3B0aW9uczogewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIGRlZmF1bHQ6IG51bGwKICAgIH0KICB9LAoKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgLyoqCiAgICAgICAqIFRoZSBBdXRvY29tcGxldGUgb2JqZWN0LgogICAgICAgKgogICAgICAgKiBAdHlwZSB7QXV0b2NvbXBsZXRlfQogICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjQXV0b2NvbXBsZXRlCiAgICAgICAqLwogICAgICBhdXRvY29tcGxldGU6IG51bGwsCgogICAgICAvKioKICAgICAgICogQXV0b2NvbXBsZXRlIGlucHV0IHRleHQKICAgICAgICogQHR5cGUge1N0cmluZ30KICAgICAgICovCiAgICAgIGF1dG9jb21wbGV0ZVRleHQ6ICcnLAogICAgICBnZW9sb2NhdGlvbjogewogICAgICAgIC8qKgogICAgICAgICAqIEdvb2dsZSBHZW9jb2RlciBPYmpldAogICAgICAgICAqIEB0eXBlIHtHZW9jb2Rlcn0KICAgICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjR2VvY29kZXIKICAgICAgICAgKi8KICAgICAgICBnZW9jb2RlcjogbnVsbCwKCiAgICAgICAgLyoqCiAgICAgICAgICogRmlsbGVkIGFmdGVyIGdlb2xvY2F0ZSByZXN1bHQKICAgICAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZXN9CiAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nvb3JkaW5hdGVzCiAgICAgICAgICovCiAgICAgICAgbG9jOiBudWxsLAoKICAgICAgICAvKioKICAgICAgICAgKiBGaWxsZWQgYWZ0ZXIgZ2VvbG9jYXRlIHJlc3VsdAogICAgICAgICAqIEB0eXBlIHtQb3NpdGlvbn0KICAgICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9zaXRpb24KICAgICAgICAgKi8KICAgICAgICBwb3NpdGlvbjogbnVsbAogICAgICB9CiAgICB9OwogIH0sCgogIHdhdGNoOiB7CiAgICBhdXRvY29tcGxldGVUZXh0OiBmdW5jdGlvbiAobmV3VmFsLCBvbGRWYWwpIHsKICAgICAgdGhpcy4kZW1pdCgnaW5wdXRDaGFuZ2UnLCB7CiAgICAgICAgbmV3VmFsLAogICAgICAgIG9sZFZhbAogICAgICB9LCB0aGlzLmlkKTsKICAgIH0sCiAgICBjb3VudHJ5OiBmdW5jdGlvbiAobmV3VmFsLCBvbGRWYWwpIHsKICAgICAgdGhpcy5hdXRvY29tcGxldGUuc2V0Q29tcG9uZW50UmVzdHJpY3Rpb25zKHsKICAgICAgICBjb3VudHJ5OiB0aGlzLmNvdW50cnkgPT09IG51bGwgPyBbXSA6IHRoaXMuY291bnRyeQogICAgICB9KTsKICAgIH0KICB9LAogIG1vdW50ZWQ6IGZ1bmN0aW9uICgpIHsKICAgIGNvbnN0IG9wdGlvbnMgPSB7fTsKCiAgICBpZiAodGhpcy50eXBlcykgewogICAgICBvcHRpb25zLnR5cGVzID0gW3RoaXMudHlwZXNdOwogICAgfQoKICAgIGlmICh0aGlzLmNvdW50cnkpIHsKICAgICAgb3B0aW9ucy5jb21wb25lbnRSZXN0cmljdGlvbnMgPSB7CiAgICAgICAgY291bnRyeTogdGhpcy5jb3VudHJ5CiAgICAgIH07CiAgICB9CgogICAgdGhpcy5hdXRvY29tcGxldGUgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKSwgb3B0aW9ucyk7CiAgICB0aGlzLmF1dG9jb21wbGV0ZS5zZXRGaWVsZHModGhpcy5maWVsZHMpOwogICAgdGhpcy5hdXRvY29tcGxldGUuYWRkTGlzdGVuZXIoJ3BsYWNlX2NoYW5nZWQnLCB0aGlzLm9uUGxhY2VDaGFuZ2VkKTsKICB9LAogIG1ldGhvZHM6IHsKICAgIC8qKgogICAgICogV2hlbiBhIHBsYWNlIGNoYW5nZWQKICAgICAqLwogICAgb25QbGFjZUNoYW5nZWQoKSB7CiAgICAgIGxldCBwbGFjZSA9IHRoaXMuYXV0b2NvbXBsZXRlLmdldFBsYWNlKCk7CgogICAgICBpZiAoIXBsYWNlLmdlb21ldHJ5KSB7CiAgICAgICAgLy8gVXNlciBlbnRlcmVkIHRoZSBuYW1lIG9mIGEgUGxhY2UgdGhhdCB3YXMgbm90IHN1Z2dlc3RlZCBhbmQKICAgICAgICAvLyBwcmVzc2VkIHRoZSBFbnRlciBrZXksIG9yIHRoZSBQbGFjZSBEZXRhaWxzIHJlcXVlc3QgZmFpbGVkLgogICAgICAgIHRoaXMuJGVtaXQoJ25vLXJlc3VsdHMtZm91bmQnLCBwbGFjZSwgdGhpcy5pZCk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAocGxhY2UuYWRkcmVzc19jb21wb25lbnRzICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAvLyByZXR1cm4gcmV0dXJuRGF0YSBvYmplY3QgYW5kIFBsYWNlUmVzdWx0IG9iamVjdAogICAgICAgIHRoaXMuJGVtaXQoJ3BsYWNlY2hhbmdlZCcsIHRoaXMuZm9ybWF0UmVzdWx0KHBsYWNlKSwgcGxhY2UsIHRoaXMuaWQpOyAvLyB1cGRhdGUgYXV0b2NvbXBsZXRlVGV4dCB0aGVuIGVtaXQgY2hhbmdlIGV2ZW50CgogICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpLnZhbHVlOwogICAgICAgIHRoaXMub25DaGFuZ2UoKTsKICAgICAgfQogICAgfSwKCiAgICAvKioKICAgICAqIFdoZW4gdGhlIGlucHV0IGdldHMgZm9jdXMKICAgICAqLwogICAgb25Gb2N1cygpIHsKICAgICAgdGhpcy5iaWFzQXV0b2NvbXBsZXRlTG9jYXRpb24oKTsKICAgICAgdGhpcy4kZW1pdCgnZm9jdXMnKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBXaGVuIHRoZSBpbnB1dCBsb3NlcyBmb2N1cwogICAgICovCiAgICBvbkJsdXIoKSB7CiAgICAgIHRoaXMuJGVtaXQoJ2JsdXInKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBXaGVuIHRoZSBpbnB1dCBnb3QgY2hhbmdlZAogICAgICovCiAgICBvbkNoYW5nZSgpIHsKICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5hdXRvY29tcGxldGVUZXh0KTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBXaGVuIGEga2V5IGdldHMgcHJlc3NlZAogICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IEEga2V5cHJlc3MgZXZlbnQKICAgICAqLwogICAgb25LZXlQcmVzcyhldmVudCkgewogICAgICB0aGlzLiRlbWl0KCdrZXlwcmVzcycsIGV2ZW50KTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBXaGVuIGEga2V5dXAgb2NjdXJzCiAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnQgQSBrZXl1cCBldmVudAogICAgICovCiAgICBvbktleVVwKGV2ZW50KSB7CiAgICAgIHRoaXMuJGVtaXQoJ2tleXVwJywgZXZlbnQpOwogICAgfSwKCiAgICAvKioKICAgICAqIENsZWFyIHRoZSBpbnB1dAogICAgICovCiAgICBjbGVhcigpIHsKICAgICAgdGhpcy5hdXRvY29tcGxldGVUZXh0ID0gJyc7CiAgICB9LAoKICAgIC8qKgogICAgICogRm9jdXMgdGhlIGlucHV0CiAgICAgKi8KICAgIGZvY3VzKCkgewogICAgICB0aGlzLiRyZWZzLmF1dG9jb21wbGV0ZS5mb2N1cygpOwogICAgfSwKCiAgICAvKioKICAgICAqIEJsdXIgdGhlIGlucHV0CiAgICAgKi8KICAgIGJsdXIoKSB7CiAgICAgIHRoaXMuJHJlZnMuYXV0b2NvbXBsZXRlLmJsdXIoKTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dAogICAgICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZQogICAgICovCiAgICB1cGRhdGUodmFsdWUpIHsKICAgICAgdGhpcy5hdXRvY29tcGxldGVUZXh0ID0gdmFsdWU7CiAgICB9LAoKICAgIC8qKgogICAgICogVXBkYXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW5wdXQKICAgICAqIEBwYXJhbSAge0Nvb3JkaW5hdGVzfSB2YWx1ZQogICAgICovCiAgICB1cGRhdGVDb29yZGluYXRlcyh2YWx1ZSkgewogICAgICBpZiAoIXZhbHVlICYmICEodmFsdWUubGF0IHx8IHZhbHVlLmxuZykpIHJldHVybjsKICAgICAgaWYgKCF0aGlzLmdlb2xvY2F0aW9uLmdlb2NvZGVyKSB0aGlzLmdlb2xvY2F0aW9uLmdlb2NvZGVyID0gbmV3IGdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7CiAgICAgIHRoaXMuZ2VvbG9jYXRpb24uZ2VvY29kZXIuZ2VvY29kZSh7CiAgICAgICAgJ2xvY2F0aW9uJzogdmFsdWUKICAgICAgfSwgKHJlc3VsdHMsIHN0YXR1cykgPT4gewogICAgICAgIGlmIChzdGF0dXMgPT09ICdPSycpIHsKICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLmZpbHRlckdlb2NvZGVSZXN1bHRUeXBlcyhyZXN1bHRzKTsKCiAgICAgICAgICBpZiAocmVzdWx0c1swXSkgewogICAgICAgICAgICB0aGlzLiRlbWl0KCdwbGFjZWNoYW5nZWQnLCB0aGlzLmZvcm1hdFJlc3VsdChyZXN1bHRzWzBdKSwgcmVzdWx0c1swXSwgdGhpcy5pZCk7CiAgICAgICAgICAgIHRoaXMudXBkYXRlKHJlc3VsdHNbMF0uZm9ybWF0dGVkX2FkZHJlc3MpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCAnbm8gcmVzdWx0IGZvciBwcm92aWRlZCBjb29yZGluYXRlcycpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLiRlbWl0KCdlcnJvcicsICdlcnJvciBnZXR0aW5nIGFkZHJlc3MgZnJvbSBjb29yZHMnKTsKICAgICAgICB9CiAgICAgIH0pOwogICAgfSwKCiAgICAvKioKICAgICAqIFVwZGF0ZSBsb2NhdGlvbiBiYXNlZCBvbiBuYXZpZ2F0b3IgZ2VvbG9jYXRpb24KICAgICAqLwogICAgZ2VvbG9jYXRlKCkgewogICAgICB0aGlzLnVwZGF0ZUdlb2xvY2F0aW9uKChnZW9sb2NhdGlvbiwgcG9zaXRpb24pID0+IHsKICAgICAgICB0aGlzLnVwZGF0ZUNvb3JkaW5hdGVzKGdlb2xvY2F0aW9uKTsKICAgICAgfSk7CiAgICB9LAoKICAgIC8qKgogICAgICogVXBkYXRlIGludGVybmFsIGxvY2F0aW9uIGZyb20gbmF2aWdhdG9yIGdlb2xvY2F0aW9uCiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gKGdlb2xvY2F0aW9uLCBwb3NpdGlvbikKICAgICAqLwogICAgdXBkYXRlR2VvbG9jYXRpb24oY2FsbGJhY2sgPSBudWxsKSB7CiAgICAgIGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHsKICAgICAgICBsZXQgb3B0aW9ucyA9IHt9OwogICAgICAgIGlmICh0aGlzLmdlb2xvY2F0aW9uT3B0aW9ucykgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLmdlb2xvY2F0aW9uT3B0aW9ucyk7CiAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihwb3NpdGlvbiA9PiB7CiAgICAgICAgICBsZXQgZ2VvbG9jYXRpb24gPSB7CiAgICAgICAgICAgIGxhdDogcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLAogICAgICAgICAgICBsbmc6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUKICAgICAgICAgIH07CiAgICAgICAgICB0aGlzLmdlb2xvY2F0aW9uLmxvYyA9IGdlb2xvY2F0aW9uOwogICAgICAgICAgdGhpcy5nZW9sb2NhdGlvbi5wb3NpdGlvbiA9IHBvc2l0aW9uOwogICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhnZW9sb2NhdGlvbiwgcG9zaXRpb24pOwogICAgICAgIH0sIGVyciA9PiB7CiAgICAgICAgICB0aGlzLiRlbWl0KCdlcnJvcicsICdDYW5ub3QgZ2V0IENvb3JkaW5hdGVzIGZyb20gbmF2aWdhdG9yJywgZXJyKTsKICAgICAgICB9LCBvcHRpb25zKTsKICAgICAgfQogICAgfSwKCiAgICAvLyBCaWFzIHRoZSBhdXRvY29tcGxldGUgb2JqZWN0IHRvIHRoZSB1c2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLAogICAgLy8gYXMgc3VwcGxpZWQgYnkgdGhlIGJyb3dzZXIncyAnbmF2aWdhdG9yLmdlb2xvY2F0aW9uJyBvYmplY3QuCiAgICBiaWFzQXV0b2NvbXBsZXRlTG9jYXRpb24oKSB7CiAgICAgIGlmICh0aGlzLmVuYWJsZUdlb2xvY2F0aW9uKSB7CiAgICAgICAgdGhpcy51cGRhdGVHZW9sb2NhdGlvbigoZ2VvbG9jYXRpb24sIHBvc2l0aW9uKSA9PiB7CiAgICAgICAgICBsZXQgY2lyY2xlID0gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZSh7CiAgICAgICAgICAgIGNlbnRlcjogZ2VvbG9jYXRpb24sCiAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5CiAgICAgICAgICB9KTsKICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLnNldEJvdW5kcyhjaXJjbGUuZ2V0Qm91bmRzKCkpOwogICAgICAgIH0pOwogICAgICB9CiAgICB9LAoKICAgIC8qKgogICAgICogRm9ybWF0IHJlc3VsdCBmcm9tIEdlbyBnb29nbGUgQVBJcwogICAgICogQHBhcmFtIHBsYWNlCiAgICAgKiBAcmV0dXJucyB7e2Zvcm1hdHRlZCBvdXRwdXR9fQogICAgICovCiAgICBmb3JtYXRSZXN1bHQocGxhY2UpIHsKICAgICAgbGV0IHJldHVybkRhdGEgPSB7fTsKCiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhY2UuYWRkcmVzc19jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgbGV0IGFkZHJlc3NUeXBlID0gcGxhY2UuYWRkcmVzc19jb21wb25lbnRzW2ldLnR5cGVzWzBdOwoKICAgICAgICBpZiAoQUREUkVTU19DT01QT05FTlRTW2FkZHJlc3NUeXBlXSkgewogICAgICAgICAgbGV0IHZhbCA9IHBsYWNlLmFkZHJlc3NfY29tcG9uZW50c1tpXVtBRERSRVNTX0NPTVBPTkVOVFNbYWRkcmVzc1R5cGVdXTsKICAgICAgICAgIHJldHVybkRhdGFbYWRkcmVzc1R5cGVdID0gdmFsOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuRGF0YVsnbGF0aXR1ZGUnXSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxhdCgpOwogICAgICByZXR1cm5EYXRhWydsb25naXR1ZGUnXSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpOwogICAgICByZXR1cm4gcmV0dXJuRGF0YTsKICAgIH0sCgogICAgLyoqCiAgICAgKiBFeHRyYWN0IGNvbmZpZ3VyZWQgdHlwZXMgb3V0IG9mIHJhdyByZXN1bHQgYXMKICAgICAqIEdlb2NvZGUgQVBJIGRvZXMgbm90IGFsbG93IHRvIGRvIGl0CiAgICAgKiBAcGFyYW0gcmVzdWx0cwogICAgICogQHJldHVybnMge0dlb2NvZGVyUmVzdWx0fQogICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI0dlb2NvZGVyUmVzdWx0CiAgICAgKi8KICAgIGZpbHRlckdlb2NvZGVSZXN1bHRUeXBlcyhyZXN1bHRzKSB7CiAgICAgIGlmICghcmVzdWx0cyB8fCAhdGhpcy50eXBlcykgcmV0dXJuIHJlc3VsdHM7CiAgICAgIGxldCBvdXRwdXQgPSBbXTsKICAgICAgbGV0IHR5cGVzID0gW3RoaXMudHlwZXNdOwogICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJyhjaXRpZXMpJykpIHR5cGVzID0gdHlwZXMuY29uY2F0KENJVElFU19UWVBFKTsKICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCcocmVnaW9ucyknKSkgdHlwZXMgPSB0eXBlcy5jb25jYXQoUkVHSU9OU19UWVBFKTsKCiAgICAgIGZvciAobGV0IHIgb2YgcmVzdWx0cykgewogICAgICAgIGZvciAobGV0IHQgb2Ygci50eXBlcykgewogICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKHQpKSB7CiAgICAgICAgICAgIG91dHB1dC5wdXNoKHIpOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBvdXRwdXQ7CiAgICB9CgogIH0KfTs="},{"version":3,"mappings":";;;;;;;;;;;;;;;;;;AAkBA;EACAA,wBADA;EAEAC,2BAFA;EAGAC,kBAHA;EAIAC,qBAJA;EAKAC,yCALA;EAMAC,wCANA;EAOAC,oBAPA;EAQAC;AARA;AAWA;AACA,2EACA,6BADA,EACA,6BADA;AAGA;AACA;AACA;;AAEA;;AAEA,0EACA,mBADA,EACA,UADA,EACA,MADA,EACA,IADA,EACA,MADA,EAEA,iBAFA,EAEA,OAFA,EAEA,UAFA,EAEA,OAFA,EAEA,MAFA,EAEA,KAFA,EAGA,oBAHA,EAGA,UAHA;AAKA;EACAC,6BADA;EAGAC;IACAC;MACAC,YADA;MAEAC;IAFA,CADA;IAMAC,iBANA;IAQAC;MACAH,YADA;MAEAI;IAFA,CARA;IAaAC;MACAL,aADA;MAEAI;IAFA,CAbA;IAkBAE;MACAN,YADA;MAEAI;IAFA,CAlBA;IAuBAG;MACAP,WADA;MAEAI;QACA;MACA;IAJA,CAvBA;IA8BAT;MACAK,qBADA;MAEAI;IAFA,CA9BA;IAmCAI;MACAR,aADA;MAEAI;IAFA,CAnCA;IAwCAK;MACAT,YADA;MAEAI;IAFA;EAxCA,CAHA;;EAiDAM;IACA;MACA;AACA;AACA;AACA;AACA;AACA;MACAC,kBAPA;;MASA;AACA;AACA;AACA;MACAC,oBAbA;MAeAC;QACA;AACA;AACA;AACA;AACA;QACAC,cANA;;QAQA;AACA;AACA;AACA;AACA;QACAC,SAbA;;QAeA;AACA;AACA;AACA;AACA;QACAC;MApBA;IAfA;EAsCA,CAxFA;;EA0FAC;IACAL;MACA;QAAAM;QAAAC;MAAA;IACA,CAHA;IAIAxB;MACA;QACAA;MADA;IAGA;EARA,CA1FA;EAqGAyB;IACA;;IAEA;MACAC;IACA;;IAEA;MACAA;QACA1B;MADA;IAGA;;IAEA,wDACA2B,gCADA,EAEAD,OAFA;IAKA;IAEA;EACA,CA1HA;EA4HAE;IACA;AACA;AACA;IACAC;MACA;;MAEA;QACA;QACA;QACA;QACA;MACA;;MAEA;QACA;QACA,qEAFA,CAIA;;QACA;QACA;MACA;IACA,CAtBA;;IAwBA;AACA;AACA;IACAC;MACA;MACA;IACA,CA9BA;;IAgCA;AACA;AACA;IACAC;MACA;IACA,CArCA;;IAuCA;AACA;AACA;IACAC;MACA;IACA,CA5CA;;IA8CA;AACA;AACA;AACA;IACAC;MACA;IACA,CApDA;;IAsDA;AACA;AACA;AACA;IACAC;MACA;IACA,CA5DA;;IA8DA;AACA;AACA;IACAC;MACA;IACA,CAnEA;;IAqEA;AACA;AACA;IACAC;MACA;IACA,CA1EA;;IA4EA;AACA;AACA;IACAC;MACA;IACA,CAjFA;;IAmFA;AACA;AACA;AACA;IACAC;MACA;IACA,CAzFA;;IA2FA;AACA;AACA;AACA;IACAC;MACA;MACA;MACA;QAAA;MAAA;QACA;UACAC;;UACA;YACA;YACA;UACA,CAHA,MAGA;YACA;UACA;QACA,CARA,MAQA;UACA;QACA;MACA,CAZA;IAaA,CA/GA;;IAiHA;AACA;AACA;IACAC;MACA;QACA;MACA,CAFA;IAGA,CAxHA;;IA0HA;AACA;AACA;AACA;IACAC;MACA;QACA;QACA;QACAC;UACA;YACAC,6BADA;YAEAC;UAFA;UAIA;UACA;UAEA;QACA,CATA,EASAC;UACA;QACA,CAXA,EAWApB,OAXA;MAYA;IACA,CA/IA;;IAkJA;IACA;IACAqB;MACA;QACA;UACA;YACAC,mBADA;YAEAC;UAFA;UAIA;QACA,CANA;MAOA;IACA,CA9JA;;IAgKA;AACA;AACA;AACA;AACA;IACAC;MACA;;MACA;QACA;;QAEA;UACA;UACAC;QACA;MACA;;MAEAA;MACAA;MACA;IACA,CAnLA;;IAqLA;AACA;AACA;AACA;AACA;AACA;AACA;IACAC;MACA;MACA;MACA;MACA;MACA;;MAEA;QACA;UACA;YACAC;YACA;UACA;QACA;MACA;;MACA;IACA;;EA5MA;AA5HA","names":["subpremise","street_number","route","locality","administrative_area_level_1","administrative_area_level_2","country","postal_code","name","props","id","type","required","classname","placeholder","default","disabled","types","fields","enableGeolocation","geolocationOptions","data","autocomplete","autocompleteText","geolocation","geocoder","loc","position","watch","newVal","oldVal","mounted","options","document","methods","onPlaceChanged","onFocus","onBlur","onChange","onKeyPress","onKeyUp","clear","focus","blur","update","updateCoordinates","results","geolocate","updateGeolocation","navigator","lat","lng","err","biasAutocompleteLocation","center","radius","formatResult","returnData","filterGeocodeResultTypes","output"],"sourceRoot":"node_modules/vue-google-autocomplete/src","sources":["VueGoogleAutocomplete.vue"],"sourcesContent":["<template>\n    <input\n        ref=\"autocomplete\"\n        type=\"text\"\n        :class=\"classname\"\n        :id=\"id\"\n        :placeholder=\"placeholder\"\n        :disabled=\"disabled\"\n        v-model=\"autocompleteText\"\n        @focus=\"onFocus()\"\n        @blur=\"onBlur()\"\n        @change=\"onChange\"\n        @keypress=\"onKeyPress\"\n        @keyup=\"onKeyUp\"\n    />\n</template>\n\n<script>\n    const ADDRESS_COMPONENTS = {\n        subpremise : 'short_name',\n        street_number: 'short_name',\n        route: 'long_name',\n        locality: 'long_name',\n        administrative_area_level_1: 'short_name',\n        administrative_area_level_2: 'long_name',\n        country: 'long_name',\n        postal_code: 'short_name'\n    };\n\n    const CITIES_TYPE = ['locality', 'administrative_area_level_3'];\n    const REGIONS_TYPE = ['locality', 'sublocality', 'postal_code', 'country',\n        'administrative_area_level_1', 'administrative_area_level_2'];\n\n    /*\n      By default, we're only including basic place data because requesting these \n      fields place data is not additionally charged by Google. Please refer to:\n\n      https://developers.google.com/maps/billing/understanding-cost-of-use#basic-data\n    */\n    const BASIC_DATA_FIELDS = ['address_components', 'adr_address', 'alt_id', \n        'formatted_address', 'geometry', 'icon', 'id', 'name', \n        'business_status', 'photo', 'place_id', 'scope', 'type', 'url', \n        'utc_offset_minutes', 'vicinity'];\n\n    export default {\n        name: 'VueGoogleAutocomplete',\n\n        props: {\n          id: {\n            type: String,\n            required: true\n          },\n\n          classname: String,\n\n          placeholder: {\n            type: String,\n            default: 'Start typing'\n          },\n\n          disabled: {\n            type: Boolean,\n            default: false\n          },\n\n          types: {\n            type: String,\n            default: 'address'\n          },\n\n          fields: {\n            type: Array,\n            default: function() {\n              return BASIC_DATA_FIELDS;\n            },\n          },\n\n          country: {\n            type: [String, Array],\n            default: null\n          },\n\n          enableGeolocation: {\n            type: Boolean,\n            default: false\n          },\n\n          geolocationOptions: {\n            type: Object,\n            default: null\n          }\n        },\n\n        data() {\n            return {\n                /**\n                 * The Autocomplete object.\n                 *\n                 * @type {Autocomplete}\n                 * @link https://developers.google.com/maps/documentation/javascript/reference#Autocomplete\n                 */\n                autocomplete: null,\n\n                /**\n                 * Autocomplete input text\n                 * @type {String}\n                 */\n                autocompleteText: '',\n\n                geolocation: {\n                    /**\n                     * Google Geocoder Objet\n                     * @type {Geocoder}\n                     * @link https://developers.google.com/maps/documentation/javascript/reference#Geocoder\n                     */\n                    geocoder: null,\n\n                    /**\n                     * Filled after geolocate result\n                     * @type {Coordinates}\n                     * @link https://developer.mozilla.org/en-US/docs/Web/API/Coordinates\n                     */\n                    loc: null,\n\n                    /**\n                     * Filled after geolocate result\n                     * @type {Position}\n                     * @link https://developer.mozilla.org/en-US/docs/Web/API/Position\n                     */\n                    position: null\n                }\n            }\n        },\n\n        watch: {\n            autocompleteText: function (newVal, oldVal) {\n\t            this.$emit('inputChange', { newVal, oldVal }, this.id);\n            },\n            country: function(newVal, oldVal) {\n              this.autocomplete.setComponentRestrictions({\n                country: this.country === null ? [] : this.country\n              });\n            }\n        },\n\n        mounted: function() {\n          const options = {};\n\n          if (this.types) {\n            options.types = [this.types];\n          }\n\n          if (this.country) {\n            options.componentRestrictions = {\n              country: this.country\n            };\n          }\n\n          this.autocomplete = new google.maps.places.Autocomplete(\n                document.getElementById(this.id),\n                options\n            );\n\n          this.autocomplete.setFields(this.fields);\n\n          this.autocomplete.addListener('place_changed', this.onPlaceChanged);\n        },\n\n        methods: {\n            /**\n             * When a place changed\n             */\n            onPlaceChanged() {\n                let place = this.autocomplete.getPlace();\n\n                if (!place.geometry) {\n                  // User entered the name of a Place that was not suggested and\n                  // pressed the Enter key, or the Place Details request failed.\n                  this.$emit('no-results-found', place, this.id);\n                  return;\n                }\n\n                if (place.address_components !== undefined) {\n                    // return returnData object and PlaceResult object\n                    this.$emit('placechanged', this.formatResult(place), place, this.id);\n\n                    // update autocompleteText then emit change event\n                    this.autocompleteText = document.getElementById(this.id).value\n                    this.onChange()\n                }\n            },\n\n            /**\n             * When the input gets focus\n             */\n            onFocus() {\n              this.biasAutocompleteLocation();\n              this.$emit('focus');\n            },\n\n            /**\n             * When the input loses focus\n             */\n            onBlur() {\n              this.$emit('blur');\n            },\n\n            /**\n             * When the input got changed\n             */\n            onChange() {\n              this.$emit('change', this.autocompleteText);\n            },\n\n            /**\n             * When a key gets pressed\n             * @param  {Event} event A keypress event\n             */\n            onKeyPress(event) {\n              this.$emit('keypress', event);\n            },\n\n            /**\n             * When a keyup occurs\n             * @param  {Event} event A keyup event\n             */\n            onKeyUp(event) {\n              this.$emit('keyup', event);\n            },\n\n            /**\n             * Clear the input\n             */\n            clear() {\n              this.autocompleteText = ''\n            },\n\n            /**\n             * Focus the input\n             */\n            focus() {\n              this.$refs.autocomplete.focus()\n            },\n\n            /**\n             * Blur the input\n             */\n            blur() {\n              this.$refs.autocomplete.blur()\n            },\n\n            /**\n             * Update the value of the input\n             * @param  {String} value\n             */\n            update (value) {\n              this.autocompleteText = value\n            },\n\n            /**\n             * Update the coordinates of the input\n             * @param  {Coordinates} value\n             */\n            updateCoordinates (value) {\n                if (!value && !(value.lat || value.lng)) return;\n                if (!this.geolocation.geocoder) this.geolocation.geocoder = new google.maps.Geocoder();\n                this.geolocation.geocoder.geocode({'location': value}, (results, status) => {\n                    if (status === 'OK') {\n                        results = this.filterGeocodeResultTypes(results);\n                        if (results[0]) {\n                            this.$emit('placechanged', this.formatResult(results[0]), results[0], this.id);\n                            this.update(results[0].formatted_address);\n                        } else {\n                            this.$emit('error', 'no result for provided coordinates');\n                        }\n                    } else {\n                        this.$emit('error', 'error getting address from coords');\n                    }\n                })\n            },\n\n            /**\n             * Update location based on navigator geolocation\n             */\n            geolocate () {\n                this.updateGeolocation ((geolocation, position) => {\n                    this.updateCoordinates(geolocation)\n                })\n            },\n\n            /**\n             * Update internal location from navigator geolocation\n             * @param  {Function} (geolocation, position)\n             */\n            updateGeolocation (callback = null) {\n                if (navigator.geolocation) {\n                    let options = {};\n                    if(this.geolocationOptions) Object.assign(options, this.geolocationOptions);\n                    navigator.geolocation.getCurrentPosition(position => {\n                        let geolocation = {\n                            lat: position.coords.latitude,\n                            lng: position.coords.longitude\n                        };\n                        this.geolocation.loc = geolocation;\n                        this.geolocation.position = position;\n\n                        if (callback) callback(geolocation, position);\n                    }, err => {\n                        this.$emit('error', 'Cannot get Coordinates from navigator', err);\n                    }, options);\n                }\n            },\n\n\n            // Bias the autocomplete object to the user's geographical location,\n            // as supplied by the browser's 'navigator.geolocation' object.\n            biasAutocompleteLocation () {\n                if (this.enableGeolocation) {\n                    this.updateGeolocation((geolocation, position) => {\n                        let circle = new google.maps.Circle({\n                            center: geolocation,\n                            radius: position.coords.accuracy\n                        });\n                        this.autocomplete.setBounds(circle.getBounds());\n                    })\n                }\n            },\n\n            /**\n             * Format result from Geo google APIs\n             * @param place\n             * @returns {{formatted output}}\n             */\n            formatResult (place) {\n                let returnData = {};\n                for (let i = 0; i < place.address_components.length; i++) {\n                    let addressType = place.address_components[i].types[0];\n\n                    if (ADDRESS_COMPONENTS[addressType]) {\n                        let val = place.address_components[i][ADDRESS_COMPONENTS[addressType]];\n                        returnData[addressType] = val;\n                    }\n                }\n\n                returnData['latitude'] = place.geometry.location.lat();\n                returnData['longitude'] = place.geometry.location.lng();\n                return returnData\n            },\n\n            /**\n             * Extract configured types out of raw result as\n             * Geocode API does not allow to do it\n             * @param results\n             * @returns {GeocoderResult}\n             * @link https://developers.google.com/maps/documentation/javascript/reference#GeocoderResult\n             */\n            filterGeocodeResultTypes (results) {\n                if (!results || !this.types) return results;\n                let output = [];\n                let types = [this.types];\n                if (types.includes('(cities)')) types = types.concat(CITIES_TYPE);\n                if (types.includes('(regions)')) types = types.concat(REGIONS_TYPE);\n\n                for (let r of results) {\n                    for (let t of r.types) {\n                        if (types.includes(t)) {\n                            output.push(r);\n                            break;\n                        }\n                    }\n                }\n                return output;\n            }\n        }\n    }\n</script>\n"]}]}